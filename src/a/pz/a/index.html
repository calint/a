<!DOCTYPE html><meta charset="utf-8"><style>
	html{white-space:pre;font-family:courier;margin:0;padding:0;margin-left:auto;margin-right:auto;padding:0 4em 0 4em;display:block;text-align:center;width:1024px;color:#222;border-right:0px dotted #666;border-left:0px dotted #666;box-shadow:0 0 27px rgba(0,0,0,1);border-radius:1px}
	title{display:inline;font-weight:bold;font-size:.5em;padding:1em;padding-top:.5em;border:1px solid gray;background:yellow;box-shadow:0 0 .5em rgba(0,0,0,.5)}
	a{text-decoration:none;color:blue}
	#scr{outline:0;border:1px solid gray;box-shadow:0 0 .5em rgba(0,0,0,.5)}
	#src{font-size:1em;line-height:1.3em;background:#eee;font-family:courier;padding-left:1em;width:20em;height:512em;border:1px dashed gray;display:block;margin-left:auto;margin-right:auto}
	#recvsize{color:green}
	#sts{color:brown}
	#f1{color:#800}
</style><title>clare</title>
<output id="f2"></output>
<img id=scr src="" alt="display" tabindex=0 onkeydown="keys[1]=event.keyCode;return false;" onkeyup="keys[1]=0;return false;">
 <output id="recvsize"></output>  <output id="outp"></output> <output id=sts></output> <a href="javascript:compile()">crun</a><output id="f1"></output><script>
$=document.all;
var keys=new Uint8Array([48,0]);
var ison=false,frameno=0,last_scr_wi=0,pause=false;
function start(){
	if(ison)return;
	ison=true;
	$.sts.value="on";
	ws=new WebSocket("ws://"+location.host+"/pz.a.porta");
	ws.binaryType="arraybuffer";
	ws.onopen=function(e){
		p(" porta");
		compile();
//		ws.send(keys);
	}
	ws.onmessage=function(e){
		onframe();
		$.recvsize.value="frame: "+frameno+"  "+e.data.byteLength+" B  "+onframe.fps+" fps";
		var ua=new DataView(e.data);
		var cmd=ua.getUint8(0);
		var dat=e.data.slice(1);
		if(cmd==48){//refresh display
			frameno++;
//			var b64=encode_base64(dat);
			var b64=base64ArrayBuffer(dat);
			$.scr.src='data:image/png;base64,'+b64;
//		    var arrayBufferView = new Uint8Array( dat );
//		    var blob = new Blob( [ arrayBufferView ], { type: "image/png" } );
//		    var urlCreator = window.URL || window.webkitURL;
//		    var imageUrl = urlCreator.createObjectURL( blob );
//		    $.scr.src=imageUrl;
			if(last_scr_wi!=$.scr.width){//scale display x2
				$.scr.width*=3;
				last_scr_wi=$.scr.width;
			}
			$.f2.value='';
		}else if(cmd==49){//text to f1 compile status
			var str=String.fromCharCode.apply(null,new Uint8Array(dat));
//			console.log('{'+str+'}')
			if(str==''){//ok
				pause=false;
				frameno=0;
				$.f1.value='';
				return;
			}else{//error
				pause=true;
				$.f1.value='\n'+str;
				return;
			}
		}else if(cmd==50){//text to f2
			pause=true;
			var str=String.fromCharCode.apply(null,new Uint8Array(dat));
			$.f2.value=str;
			return;
		}
		//console.log(keys);
		if(!pause){
			$.sts.value=keys[1];
			ws.send(keys);
		}
	};
	ws.onerror=function(e){console.log("websocket error");};
	$.scr.focus();
}
function stop(){
	ison=false;
	ws.close();
	$.outp.value="";
	$.sts.value="off";
//	$.scr.focus();
}
function compile(){
	ws.send("1"+$.src.value);
	$.scr.focus();
}
function p(txt){$.outp.value+=txt;}
function onframe(){
	var t=new Date().getTime();
	var dt=t-onframe.t0;
	if(dt>1000){
		onframe.t0=t;
		var df=frameno-onframe.f0;
		onframe.f0=frameno;
		onframe.fps=Math.floor(dt==0?0:df*1000/dt);
	}
}
onframe.t0=0;
onframe.f0=0;
onframe.fps=0;

onload=start;
</script>
<textarea id=src spellcheck=false>
#define line_width 100

// clr(400,100,70,f00,080+p)
li m line_width
li a 400   // yyxx

// if(++nlines>30h)nlines=1
li f :nlines
ld c f
inc c
li n 30
sub n c
ifn li c 1
st f c

//li c 30    // nlines
li d 080   // rgb
add d p
call clr

// drwrects(400,100,rects)
//li m 100     // line width
li a 400     // yyxx
li b :rects  // list
call drwrects

// drwblits(400,blits)
li a 400     // yyxx
li k :blits  // list
call drwblits

// typewriter(400,txt)
li a 400     // yyxx
li b :txt    // list
call typewriter

// drwdots(400,dots)
li a 400     // yyxx
li f :dots   // list
call drwdots

// *300=p++
inc p
li a 300
st a p

// c=*b=blits++
li b :blits
inc b
ld c b
// e=*7ffff
li k 7fff

// e=*k
// switchi{c+=1}{c-=1}{}
li d 1
ld e k
ifp add c d
ifz sub c d
// *b=c
st b c
..
nlines:
. 30

// clr(scr a,linewi m,height c,rgb d)
//  a,d
clr:
lp c
  lp m
    stc a d nxt
    inc d nxt ret
..
// typewriter(scr a,linewi m,str b)
//  c,j,f,g,i,d,b
typewriter:
li c 4     // const c=4
li j f00   // const j=f00
tx f m     // f=m
sub f c    // f-=c
li g -400  // g-=400
add g c    // g+=c
ldc i b    // var i=*b++
lp i       // times i
  ldc d b  //   d=*b++
  call type nxt // type(a,d,g,j)nxt
ret
..
// type(scr a,chbmp d,chwi c,rgb j,g)
//  a,d,j
type:
// times c
lp c
//  times c
  lp c
    // d<<=1
    shf d -1
    // switchi{*a=j}{a++}{a++}
    ifn stc a j
    ifp inc a
    ifz inc a
    // j++;nxt
    inc j nxt
  // a+=f;nxt
  add a f nxt
// a+=g;ret   
add a g ret    
..
// drwdots(scr a,dots f)
//  c,g,h
drwdots:
ldc c f
lp c
  ldc g f   // dot addr
  ldc h f   // dot color
  add g a   // offset
  stc g h nxt ret
..
// drwrects(scr a,linewi m,rects b)
//  b,c,a,d,e,f,g
drwrects:
ldc c b
lp c
  ldc a b
  ldc d b
  ldc e b
  ldc f b
  tx g m
  sub g f
  lp e
    lp f
      stc a d nxt
    add a g nxt
  nxt ret
..
// drwblits(scr a,blits k,scrwi m)
//  j,a,b,h,i,e,d
drwblits:
ldc j k
lp j
  ldc a k  // yyxx
  ldc b k  // from
  ldc h k  // wi
  ldc i k  // hi
  tx e m   // e=m-h
  sub e h  //
  lp i
    lp h
      ldc d b
      ifz inc a nxt
      ifp stc a d nxt
      ifn stc a d nxt
    add b e
    add a e nxt
  nxt ret
..
dots:
. 1
// yyxx  rgb
. 0100 0f00 
..
rects:
. 5
// yyxx  rgb  wi   hi 
. 3830 0422 0010 0010
. 040c 0fff 0008 0008
. 0400 0eee 0008 0008
. 1000 0ddd 0008 0008
. 100c 0ccc 0008 0008
..
blits:
. 10
// yyxx from  wi   hi
. 1030 0000 0020 0020
. 2080 0000 0020 0020
. 4080 0000 0020 0020
. 6080 0000 0020 0020
. 04a0 0000 0020 0020
. 20a0 0000 0020 0020
. 40a0 0000 0020 0020
. 60a0 0000 0020 0020
. 04c0 0000 0020 0020
. 20c0 0000 0020 0020
. 40c0 0000 0020 0020
. 60c0 0000 0020 0020
. 04e0 0000 0020 0020
. 20e0 0000 0020 0020
. 40e0 0000 0020 0020
. 60e0 0000 0020 0020

txt:
. 12
. 000f 00ff 0fff 0175
. 0767 0043
. 0043 0252 0126 ffff
. ffff ffff ffff ffff
. ffff ffff ffff ffff
. ffff ffff ffff ffff
. ffff ffff ffff ffff
. ffff ffff ffff ffff
. ffff ffff ffff ffff
</textarea> 

<script>
//from
//  http://stackoverflow.com/questions/11089732/display-image-from-blob-using-javascript-and-websockets
//public method for encoding an Uint8Array to base64
function encode_base64 (input) {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var output = "";
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0;

    while (i < input.length) {
        chr1 = input[i++];
        chr2 = i < input.length ? input[i++] : Number.NaN; // Not sure if the index 
        chr3 = i < input.length ? input[i++] : Number.NaN; // checks are needed here

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
            enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
            enc4 = 64;
        }
        output += keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                  keyStr.charAt(enc3) + keyStr.charAt(enc4);
    }
    return output;
}


// from https://gist.github.com/jonleighton/958841
// Converts an ArrayBuffer directly to base64, without any intermediate 'convert to string then
// use window.btoa' step. According to my tests, this appears to be a faster approach:
// http://jsperf.com/encoding-xhr-image-data/5

function base64ArrayBuffer(arrayBuffer) {
  var base64    = ''
  var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

  var bytes         = new Uint8Array(arrayBuffer)
  var byteLength    = bytes.byteLength
  var byteRemainder = byteLength % 3
  var mainLength    = byteLength - byteRemainder

  var a, b, c, d
  var chunk

  // Main loop deals with bytes in chunks of 3
  for (var i = 0; i < mainLength; i = i + 3) {
    // Combine the three bytes into a single integer
    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

    // Use bitmasks to extract 6-bit segments from the triplet
    a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
    b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
    c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
    d = chunk & 63               // 63       = 2^6 - 1

    // Convert the raw binary segments to the appropriate ASCII encoding
    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
  }

  // Deal with the remaining bytes and padding
  if (byteRemainder == 1) {
    chunk = bytes[mainLength]

    a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

    // Set the 4 least significant bits to zero
    b = (chunk & 3)   << 4 // 3   = 2^2 - 1

    base64 += encodings[a] + encodings[b] + '=='
  } else if (byteRemainder == 2) {
    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

    a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
    b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

    // Set the 2 least significant bits to zero
    c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

    base64 += encodings[a] + encodings[b] + encodings[c] + '='
  }
  
  return base64
}
</script>





#define scr 1000
#define nlines 10
#define colr 800
li a scr
li c nlines
li d colr
call draw
..
typedef int
int r f00
int g 0f0
int b 00f
li c 10
li a 400
#define nlines 10
..
draw:
  lp c
    stc a d nxt ret
..